package ventures.clade.clade_midtrans

import io.flutter.plugin.common.MethodCall
import io.flutter.plugin.common.MethodChannel
import io.flutter.plugin.common.MethodChannel.MethodCallHandler
import io.flutter.plugin.common.MethodChannel.Result
import io.flutter.plugin.common.PluginRegistry.Registrar
import android.app.Activity
import android.util.Log
import com.midtrans.sdk.corekit.models.snap.TransactionResult
import com.midtrans.sdk.corekit.callback.TransactionFinishedCallback
import com.midtrans.sdk.corekit.core.Constants.ADDRESS_TYPE_BOTH
import com.midtrans.sdk.uikit.SdkUIFlowBuilder
import com.midtrans.sdk.corekit.core.LocalDataHandler
import com.midtrans.sdk.corekit.models.UserAddress
import com.midtrans.sdk.corekit.models.UserDetail
import com.midtrans.sdk.corekit.core.MidtransSDK
import com.midtrans.sdk.corekit.core.PaymentMethod
import com.midtrans.sdk.corekit.core.TransactionRequest
import com.midtrans.sdk.corekit.models.ItemDetails
import java.util.*

class CladeMidtransPlugin(private val activity: Activity,
                          private val methodChannel: MethodChannel) : MethodCallHandler {

  private var itemDetailList: ArrayList<ItemDetails> = ArrayList()

  companion object {
    @JvmStatic
    fun registerWith(registrar: Registrar) {
      val channelName = "ventures.clade.midtrans"
      val methodChannel = MethodChannel(registrar.messenger(), channelName)
      val instance = CladeMidtransPlugin(registrar.activity(), methodChannel)

      methodChannel.setMethodCallHandler(instance)
    }
  }

  override fun onMethodCall(call: MethodCall, result: Result) {
    when (call.method) {
      "initMidtransSdk" -> {
        val clientKey = call.argument<String>("clientKey")
        val baseUrl = call.argument<String>("baseUrl")
        initMidtransSdk(clientKey!!, baseUrl!!)
      }
      "setUserDetail" -> {
        val userDetail = call.argument<HashMap<String, String>>("userMap")
        setUserDetail(userDetail!!)
      }
      "addItemDetail" -> {
        val id = call.argument<String>("id")
        val price = call.argument<Double>("price")
        val quantity = call.argument<Int>("quantity")
        val name = call.argument<String>("name")
        addItemDetail(id!!, price!!, quantity!!, name!!)
      }
      "setTransactionRequest" -> {
        val transactionId = call.argument<String>("transactionId")
        val totalAmount = call.argument<Double>("totalAmount")
        setTransactionRequest(transactionId!!, totalAmount!!)
      }
      "startPayment" -> {
        val skipCustomerDetails = call.argument<Boolean>("skipCustomerDetails")
        val snapToken = call.argument<String>("snapToken")
        startPayment(skipCustomerDetails!!, snapToken)
      }
      "startPaymentWithSpecificMethod" -> {
        val skipCustomerDetails = call.argument<Boolean>("skipCustomerDetails")
        val snapToken = call.argument<String>("snapToken")
        val paymentMethod = call.argument<Int>("paymentMethod")
        startPaymentWithSpecificMethod(skipCustomerDetails!!,
                PaymentMethod.values()[paymentMethod!!], snapToken)
      }
      else -> {
        result.notImplemented()
      }
    }
  }
  var logTag:String = "CladeMidtrans"

  private fun onTransactionFinishedHandler(p0: TransactionResult?) {
    Log.i(logTag, "TRX Finished")
    p0?.let {
      // TODO map TransactionResult as response
      /*var res = HashMap<String, Any>()
      res["status"] = it.status
      res["isTransactionCancelled"] = it.isTransactionCanceled
      res["source"] = it.source
      res["statusMessage"] = it.statusMessage
      res["responseMessage"] = it.response*/
      var status = if (it.status == null) "cancelled" else it.status
      methodChannel.invokeMethod("onTransactionFinished", status)
      Log.i(logTag,"with status ${it.status}")
    }
  }

  private fun initMidtransSdk(clientKey: String, baseUrl: String) {
    SdkUIFlowBuilder.init()
            .setClientKey(clientKey) // client_key is mandatory
            .setContext(activity) // context is mandatory
            .setTransactionFinishedCallback { p0 -> onTransactionFinishedHandler(p0) } // set transaction finish callback (sdk callback)
            .setMerchantBaseUrl(baseUrl) //set merchant url (required)
            .enableLog(true) // enable sdk log (optional)
            .buildSDK()

    itemDetailList = ArrayList()
  }

  private fun setUserDetail(userMap: HashMap<String, String>) {
    var userDetail = UserDetail()
    userDetail.userFullName = userMap["userFullName"]
    userDetail.email = userMap["email"]
    userDetail.phoneNumber = userMap["phoneNumber"]
    // set user ID as identifier of saved card (can be anything as long as unique),
    // randomly generated by SDK if not supplied
    userDetail.userId = userMap["userId"]

    val userAddresses = ArrayList<UserAddress>()
    val userAddress = UserAddress()
    userAddress.address = userMap["address"]
    userAddress.city = userMap["city"]

    userAddress.addressType = ADDRESS_TYPE_BOTH
    userAddress.zipcode = userMap["zipCode"]
    userAddress.country = userMap["country"]
    userAddresses.add(userAddress)
    userDetail.userAddresses = userAddresses
    LocalDataHandler.saveObject("user_details", userDetail)
  }


  private fun addItemDetail(id: String, price: Double, quantity: Int, name: String) {
    var itemDetail = ItemDetails(id, price, quantity, name)
    itemDetailList.add(itemDetail)
  }

  private fun setTransactionRequest(transactionId: String, totalAmount: Double) {
    val transactionRequest = TransactionRequest(transactionId, totalAmount)
    transactionRequest.itemDetails = itemDetailList;

    MidtransSDK.getInstance().transactionRequest = transactionRequest
  }

  private fun startPayment(skipCustomerDetails: Boolean, snapToken: String?) {
    val setting = MidtransSDK.getInstance().uiKitCustomSetting
    setting.isSkipCustomerDetailsPages = skipCustomerDetails
    MidtransSDK.getInstance().uiKitCustomSetting = setting
    if (snapToken.isNullOrEmpty()) {
      MidtransSDK.getInstance().startPaymentUiFlow(activity)
    } else {
      MidtransSDK.getInstance().startPaymentUiFlow(activity, snapToken)
    }
  }

  private fun startPaymentWithSpecificMethod(skipCustomerDetails: Boolean,
                                             paymentMethod: PaymentMethod, snapToken: String?) {
    val setting = MidtransSDK.getInstance().uiKitCustomSetting
    setting.isSkipCustomerDetailsPages = skipCustomerDetails
    MidtransSDK.getInstance().uiKitCustomSetting = setting
    if (snapToken.isNullOrEmpty()) {
      MidtransSDK.getInstance().startPaymentUiFlow(activity, paymentMethod)
    } else {
      MidtransSDK.getInstance().startPaymentUiFlow(activity, paymentMethod, snapToken)
    }
  }
}
